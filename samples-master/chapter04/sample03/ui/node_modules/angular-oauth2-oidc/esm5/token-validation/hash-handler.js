import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
/**
 * Abstraction for crypto algorithms
*/
var HashHandler = /** @class */ (function () {
    function HashHandler() {
    }
    return HashHandler;
}());
export { HashHandler };
var DefaultHashHandler = /** @class */ (function () {
    function DefaultHashHandler() {
    }
    DefaultHashHandler.prototype.calcHash = function (valueToHash, algorithm) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var encoder, data, hashArray;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        encoder = new TextEncoder();
                        data = encoder.encode(valueToHash);
                        return [4 /*yield*/, window.crypto.subtle.digest(algorithm, data)];
                    case 1:
                        hashArray = _a.sent();
                        return [2 /*return*/, this.toHashString(hashArray)];
                }
            });
        });
    };
    DefaultHashHandler.prototype.toHashString = function (buffer) {
        var e_1, _a;
        var byteArray = new Uint8Array(buffer);
        var result = '';
        try {
            for (var byteArray_1 = tslib_1.__values(byteArray), byteArray_1_1 = byteArray_1.next(); !byteArray_1_1.done; byteArray_1_1 = byteArray_1.next()) {
                var e = byteArray_1_1.value;
                result += String.fromCharCode(e);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (byteArray_1_1 && !byteArray_1_1.done && (_a = byteArray_1.return)) _a.call(byteArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    DefaultHashHandler = tslib_1.__decorate([
        Injectable()
    ], DefaultHashHandler);
    return DefaultHashHandler;
}());
export { DefaultHashHandler };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaC1oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1vYXV0aDItb2lkYy8iLCJzb3VyY2VzIjpbInRva2VuLXZhbGlkYXRpb24vaGFzaC1oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDOztFQUVFO0FBQ0Y7SUFBQTtJQUVBLENBQUM7SUFBRCxrQkFBQztBQUFELENBQUMsQUFGRCxJQUVDOztBQUdEO0lBQUE7SUF1Q0EsQ0FBQztJQXJDUyxxQ0FBUSxHQUFkLFVBQWUsV0FBbUIsRUFBRSxTQUFpQjs7Ozs7O3dCQUMzQyxPQUFPLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQzt3QkFDNUIsSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7d0JBQ3ZCLHFCQUFNLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUE7O3dCQUE5RCxTQUFTLEdBQUcsU0FBa0Q7d0JBQ3BFLHNCQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLEVBQUM7Ozs7S0FDdkM7SUFFRCx5Q0FBWSxHQUFaLFVBQWEsTUFBbUI7O1FBQzlCLElBQU0sU0FBUyxHQUFHLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQzs7WUFDaEIsS0FBYyxJQUFBLGNBQUEsaUJBQUEsU0FBUyxDQUFBLG9DQUFBLDJEQUFFO2dCQUFwQixJQUFJLENBQUMsc0JBQUE7Z0JBQ1IsTUFBTSxJQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDbEM7Ozs7Ozs7OztRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFoQlEsa0JBQWtCO1FBRDlCLFVBQVUsRUFBRTtPQUNBLGtCQUFrQixDQXVDOUI7SUFBRCx5QkFBQztDQUFBLEFBdkNELElBdUNDO1NBdkNZLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBmb3IgY3J5cHRvIGFsZ29yaXRobXNcclxuKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhhc2hIYW5kbGVyIHtcclxuICAgIGFic3RyYWN0IGNhbGNIYXNoKHZhbHVlVG9IYXNoOiBzdHJpbmcsIGFsZ29yaXRobTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+O1xyXG59XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0SGFzaEhhbmRsZXIgaW1wbGVtZW50cyBIYXNoSGFuZGxlciB7XHJcblxyXG4gICAgYXN5bmMgY2FsY0hhc2godmFsdWVUb0hhc2g6IHN0cmluZywgYWxnb3JpdGhtOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUodmFsdWVUb0hhc2gpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hBcnJheSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvSGFzaFN0cmluZyhoYXNoQXJyYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHRvSGFzaFN0cmluZyhidWZmZXI6IEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgIGxldCByZXN1bHQgPSAnJztcclxuICAgICAgZm9yIChsZXQgZSBvZiBieXRlQXJyYXkpIHtcclxuICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGhleFN0cmluZyhidWZmZXIpIHtcclxuICAgIC8vICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgLy8gICAgIGNvbnN0IGhleENvZGVzID0gWy4uLmJ5dGVBcnJheV0ubWFwKHZhbHVlID0+IHtcclxuICAgIC8vICAgICAgIGNvbnN0IGhleENvZGUgPSB2YWx1ZS50b1N0cmluZygxNik7XHJcbiAgICAvLyAgICAgICBjb25zdCBwYWRkZWRIZXhDb2RlID0gaGV4Q29kZS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgLy8gICAgICAgcmV0dXJuIHBhZGRlZEhleENvZGU7XHJcbiAgICAvLyAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgLy8gICAgIHJldHVybiBoZXhDb2Rlcy5qb2luKCcnKTtcclxuICAgIC8vICAgfVxyXG4gICAgXHJcbiAgICAgIC8vIHRvSGFzaFN0cmluZyhoZXhTdHJpbmc6IHN0cmluZykge1xyXG4gICAgICAvLyAgIGxldCByZXN1bHQgPSAnJztcclxuICAgICAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IGhleFN0cmluZy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAvLyAgICAgbGV0IGhleERpZ2l0ID0gaGV4U3RyaW5nLmNoYXJBdChpKSArIGhleFN0cmluZy5jaGFyQXQoaSArIDEpO1xyXG4gICAgICAvLyAgICAgbGV0IG51bSA9IHBhcnNlSW50KGhleERpZ2l0LCAxNik7XHJcbiAgICAgIC8vICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShudW0pO1xyXG4gICAgICAvLyAgIH1cclxuICAgICAgLy8gICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAvLyB9XHJcblxyXG59Il19